# 06 정렬

## 보조 정렬

보조 정렬은 키의 값들을 그룹핑하고, 그룹핑된 레코드에 순서를 부여하는 방식

**구현 방법**

1. 기존 키의 값들을 조합한 복합키(Composite Key)를 정의합니다. 이때 키의 값 중에서 어떤 키를 그룹핑 키로 사용할지 결정합니다.
2. 복합키의 레코드를 정렬하기 위한 비교기(Comparator)를 정의합니다.
3. 그룹핑 키를 파티셔닝할 파티셔너(Partitioner)를 정의합니다.
4. 그룹핑 키를 정렬하기 위한 비교기(Comparator)를 정의합니다.

### 복합키 구현

복합키는 기존의 키값을 조합한 일종의 키 집합 클래스 : 연도와 월이 각각 멤버 변수로 정의

WritableComparable 인터페이스

- readFields : 입력 스트림에서 연도와 월을 조회
- write : 출력 스트림에 연도와 월을 출력
- compareTo : 복합키와 복합키를 비교해 순서 정할 때 사용

### 복합키 비교기 구현

복합키의 정렬 순서를 부여하기 위한 클래스

두 개의 복합키를 비교하게 되며, 각 멤버 변수를 비교해 정렬 순서를 정함

compare 메서드는 이미 WritableComparator에 구현되어 있지만, 객체를 스트림에서 조회한 값을 비교하게 되므로 정확한 정렬 순서를 부과할 수 없음 → 메서드 재정의하여 멤버 변수를 비교하는 로직을 구현해야만 함

### 그룹키 파티셔너 구현

맵 태스크의 출력 데이터를 리듀스 태스크의 입력 데이터로 보낼지 결정하고, 파티셔닝된 데이터는 맵 태스크의 출력 데이터의 키의 값에 따라 정렬

맵리듀스 잡에서 사용하는 파티셔너는 반드시 Partitioner를 상속받아 구현해야 함

### 그룹키 비교기 구현

리듀서는 그룹키 비교기를 사용해 같은 연도에 해당하는 모든 데이터를 하나의 Reducer 그룹에서 처리할 수 있음

### 매퍼 구현

복합키를 사용하는 매퍼 구현

### 리듀서 구현

매퍼의 출력 데이터를 전달받아 연도와 월별로 지연 횟수를 합산

월별로 지연 횟수를 계산하려면 복합키를 구분해서 처리하는 코드 구현 필요

### 드라이버 구현

지금까지 작성한 클래스를 구동하는 드라이버 클래스

그룹키 파티셔너, 그룹키 비교기, 복합키 비교기를 잡에 등록

매퍼와 리듀서의 출력 데이터 포맷에 복합키와 지연횟수 설정

### 드라이버 실행

## 부분 정렬

매퍼의 출력 데이터를 맵파일로 변경해 데이터를 검색하는 방법

맵 태스크가 실행될 때 파티셔너는 매퍼의 출력 데이터가 어떤 리듀스 태스크로 전달될지 결정하고, 파티셔닝된 데이터는 키에 따라 정렬됨

부분 정렬을 하기 위해 파티셔닝된 출력 데이터를 맵파일로 변경

특정 키에 대한 데이터를 검색할 경우 해당 키에 대한 데이터가 저장된 맵파일에 접근해 데이터를 조회

미국 항공 지연 통계 데이터를 항공 운항 거리 순서대로 정렬하는 부분 정렬 프로그램

1. 입력 데이터를 시퀀스파일로 생성
2. 시퀀스파일을 맵파일로 변경
3. 맵파일에서 데이터 검색

*부분 정렬은 mapred 패키지를 이용해 맵리듀스 프로그램을 개발해야 함

### 시퀀스파일 생성

### 맵파일 생성

맵파일은 키값을 검색할 수 있게 색인과 함께 정렬된 시퀀스파일

맵파일은 물리적으로 색인이 저장된 index 파일과 데이터 내용이 저장돼 있는 data 파일로 구성됨

### 검색 프로그램 구현

데이터 검색 프로그램은 맵리듀스 프로그램이 아님. 맵파일에서 원하는 데이터만 검색하면 되기 때문에 맵리듀스로 구현할 필요가 없음.

검색의 키는 파티셔너. 검색하고자 하는 키가 속하는 파티션 번호를 조회한 후, 파티션 번호로 접근해 데이터를 검색

1. 사용자가 입력한 폴더에 대한 파일 시스템 객체 생성
2. MapFileOutputFormat의 getReaders 메서드를 이용해 해당 폴더가 저장된 맵파일을 조회
    
    (Reader는 맵파일에 저장된 데이터 목록을 순회하면서 데이터를 조회하는 API)
    
3. 맵파일에 접근하려면 파티션 정보가 필요하므로 해시 파티셔너를 생성(해시 파티셔너로 생성하는 이유: 앞 단계에서 만들어진 맵파일이 해시 파티셔너로 파티셔닝되었기 때문)
4. 파티셔너의 getPartition 메서드를 통해 특정 키에 대한 파티션 번호를 반환
5. Reader의 get 메서드를 사용해 특정 키에 해당하는 값을 검색(이때 반환된 값은 데이터 목록에서 첫 번째 값)

*MapFileOutputFormat의 메서드는 파라미터로 전달받은 폴더에 있는 모든 폴더에서 맵파일이 존재하는지 체크

## 전체 정렬

모든 맵리듀스 잡은 입력 데이터의 키를 기준으로 정렬 → 하나의 파티션으로 손쉽게 데이터를 정렬할 수 있음

But. 수십 기가바이트의 데이터를 정렬할 경우 문제가 발생할 수 있음

: 리듀스 태스크를 실행하지 않는 데이터 노드는 가동되지 않고, 리듀스 태스크가 실행되는 데이터노드에만 부하 집중

분산 처리의 장점을 살리면서 전체 정렬

1. 입력 데이터를 샘플링해서 데이터의 분포도를 조사
2. 데이터의 분포도에 맞게 파티션 정보를 미리 생성
3. 미리 생성한 파티션 정보에 맞게 출력 데이터를 생성
4. 각 출력 데이터를 병합

TotalOrderPartitioner: 파티션 개수와 파티션에 저장할 데이터 범위를 설정할 수 있음(데이터 분포 잘못 계산해서 특정 파티션에 데이터가 집중되면 해당 파티션 처리하는 데이터노드에 부하 걸림)

InputSampler: 입력 데이터에서 특정 개수의 데이터를 추출해 키와 데이터 건수를 샘플링(데이터의 분포도 작성)

TotalOrderPartitioner는 위의 샘플링 결과를 기준으로 파티션 생성, 맵 리듀스 잡은 생성된 파티션에 출력 데이터를 생성

*시퀀스파일을 출력 포맷으로 사용하는 이유: TotalOrderPartitioner가 시퀀스파일을 사용하도록 최적화되어 있음

InputSampler에서 제공하는 세 가지 샘플러

| SplitSampler | 입력 스플릿에서 첫번째 레코드의 키를 수집. |
| --- | --- |
| IntervalSampler | 입력 스플릿에서 일정한 간격으로 키를 수집. |
| RandomSampler | 일정 스플릿 건수에서 일정 확률로 키를 수집. 이때 스플릿 건수와 확률은 사용자가 설정, 샘플링한 데이터 건수도 임의로 설정할 수 있음. |

결과로 나온 각 파티션은 키 순서대로 정렬되어 있으며, 이 파일들을 합치면 전체 정렬한 효과를 볼 수 있음

부분 정렬 vs. 전체 정렬

정렬된 결과에서 데이터를 검색할 필요가 있다면 부분 정렬, 단순히 정렬된 전체 데이터만 필요하다면 전체 정렬 이용