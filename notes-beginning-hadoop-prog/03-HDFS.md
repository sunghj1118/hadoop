# 03 하둡 분산 파일 시스템

## HDFS 기초

### 목표

1. 장애 복구
    1. HDFS에 데이터를 저장하면, 복제 데이터도 함께 저장되어 데이터 유실을 방지
    2. 분산 서버 간에는 주기적으로 상태를 체크해 빠른 시간에 장애를 인지, 대처
2. 스트리밍 방식의 데이터 접근
    1. 동일한 시간 내에 더 많은 데이터를 처리하는 것을 목표로 함 → 랜덤 방식의 데이터 접근을 고려x
    2. 스트리밍 방식 → 끊김 없이 연속된 흐름으로 데이터에 접근
3. 대용량 데이터 저장
    1. 하나의 파일이 기가바이트에서 테라바이트 이상의 크기로 저장될 수 있게 설계
    2. 높은 데이터 전송 대역폭과 하나의 클러스터에서 수백 대의 노드를 지원할 수 있음
4. 데이터 무결성
    1. 한 번 저장한 데이터는 더는 수정할 수 없고, 읽기만 가능하게 해서 데이터 무결성 유지
    2. 데이터 수정은 불가능하지만 파일 이동, 삭제, 복사할 수 있는 인터페이스 제공

## HDFS 아키텍처

### 블록 구조 파일 시스템

HDFS에 저장하는 파일은 특정 크기의 블록으로 나눠져 분산된 서버에 저장됨

분산된 서버에 나눠서 데이터를 저장하기 때문에 로컬 서버의 하드디스크보다 큰 규모의 데이터를 저장할 수 있는 것이고, 저장할 수 있는 용량을 수십 기가, 테라, 페타바이트까지 확대할 수 있음

블록의 크기가 왜 64메가바이트?

- 디스크 시트 타임의 감소
    - HDFS는 시크 다임이 디스크 전송 대역폭의 1%만 사용하는 데 주안점을 두어 100MB에 근접한 64MB를 사용 → 2.0부터는 128MB
- 네임노드가 유지하는 메타데이터 크기 감소
    - 네임노드는 블록 위치, 파일명, 디렉토리 구조, 권한 정보와 같은 메타데이터 정보를 메모리에 저장하고 관리
    - 일반적인 파일 시스템은 블록 크기가 4k~8k이기 때문에 동일 크기의 파일 저장할 때 훨씬 많은 메타데이터 생성됨
    - 네임노드가 관리하는 블록의 개수는 네임노드에 할당된 힙 메모리 크기에 영향을 받게 됨
- 클라이언트와 네임노드의 통신 감소
    - 클라이언트가 HDFS에 저장된 파일을 접근할 때 네임노드에서 해당 파일을 구성하는 블록의 위치 조회
    - 클라이언트는 스트리밍 방식으로 데이터를 읽고 쓰기 때문에 특별한 경우를 제외하고는 네임노드와 통신할 필요 없어짐
    - HDFS는 블록을 저장할 때 기본적으로 3개씩 블록의 복제본을 저장
    

### 네임노드와 데이터 노드

HDFS는 마스터-슬레이브 아키텍처 : 네임노드-데이터노드

![!\[Untitled\](03%20%E1%84%92%E1%85%A1%E1%84%83%E1%85%AE%E1%86%B8%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20c6796316a8384a41a7b2f61f95c30367/Untitled.png)](images/ch3-0.png)

네임노드

- 메타데이터 관리
    - 클라이언트에게 빠르게 응답할 수 있게 메모리에 전체 메타데이터를 로딩해서 관리
- 데이터노드 모니터링
    - 데이터노드로부터 오는 하트비트를 이용해 데이터노드의 실행 상태와 용량 모니터링
- 블록 관리
    - 데이터노드에 장애 발생 → 해당 데이터노드의 블록을 새로운 데이터노드로 복제
    - 용량이 부족한 데이터노드 → 여유 있는 데이터노드로 블록 이동
    - 블록의 복제본 수도 관리 → 일치하지 않는 블록 발견 → 추가로 복제, 삭제
- 클라이언트 요청 접수
    - 클라이언트가 HDFS에 접근하려면 반드시 네임노드에 먼저 접속해야함
    

데이터노드

- 클라이언트가 HDFS에 저장하는 파일을 로컬디스크에 유지 (두 종류 - 로우 데이터, 메타데이터)

### HDFS의 파일 저장

1. 파일 저장 요청
    
    클라이언트가 HDFS에 파일을 저장하는 경우 파일을 저장하기 위한 스트림 생성해야 함
    
    ![!\[Untitled\](03%20%E1%84%92%E1%85%A1%E1%84%83%E1%85%AE%E1%86%B8%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20c6796316a8384a41a7b2f61f95c30367/Untitled%201.png)](images/ch3-1.png)
    
2. 패킷 전송
    
    클라이언트는 파일을 네임노드에게 전송하지 않고 각 데이터노드에 전송. 저장할 파일은 패킷 단위로 나눠서 전송
    
    ![!\[Untitled\](03%20%E1%84%92%E1%85%A1%E1%84%83%E1%85%AE%E1%86%B8%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20c6796316a8384a41a7b2f61f95c30367/Untitled%202.png)](images/ch3-2.png)
    
3. 파일 닫기
    
    ![!\[Untitled\](03%20%E1%84%92%E1%85%A1%E1%84%83%E1%85%AE%E1%86%B8%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20c6796316a8384a41a7b2f61f95c30367/Untitled%203.png)](images/ch3-3.png)
    

### HDFS의 파일 읽기

1. 파일 조회 요청
    
    ![!\[Untitled\](03%20%E1%84%92%E1%85%A1%E1%84%83%E1%85%AE%E1%86%B8%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20c6796316a8384a41a7b2f61f95c30367/Untitled%204.png)](images/ch3-4.png)
    
2. 블록 조회
    
    ![!\[Untitled\](03%20%E1%84%92%E1%85%A1%E1%84%83%E1%85%AE%E1%86%B8%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20c6796316a8384a41a7b2f61f95c30367/Untitled%205.png)](images/ch3-5.png)
    
3. 입력 스트림 닫기
    
    ![!\[Untitled\](03%20%E1%84%92%E1%85%A1%E1%84%83%E1%85%AE%E1%86%B8%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20c6796316a8384a41a7b2f61f95c30367/Untitled%206.png)](images/ch3-6.png)
    

### 보조네임노드

메모리에만 데이터를 유지할 경우 서버가 재부팅될 때 모든 메타데이터가 유실될 수 있음

→ editslog와 fsimage라는 두 개의 파일 생성

1. 네임노드가 구동되면 로컬에 저장된 fsimage와 editslog를 조회
2. 메모리에 fsimage를 로딩해 파일 시스템 이미지 생성
3. 메모리에 로딩된 파일 시스템 이미지에 editslog에 기록된 변경 이력을 적용
4. 메모리에 로딩된 파일 시스템 이미지를 이용해 fsimage 파일을 갱신
5. editslog 초기화
6. 데이터노드가 전송한 블록리포트를 메모리에 로딩된 파일 시스템 이미지에 적용

→ editslog 크기가 클 경우 문제가 될 수 있음

→ 보조네임노드라는 노드 제공 : 주기적으로 네임노드의 fsimage를 갱신(체크포인트)

![!\[Untitled\](03%20%E1%84%92%E1%85%A1%E1%84%83%E1%85%AE%E1%86%B8%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20c6796316a8384a41a7b2f61f95c30367/Untitled%207.png)](images/ch3-7.png)

보조네임노드는 네임노드의 백업노드가 아니고, 네임노드의 fsimage를 축소시켜주는 역할

여러 원인으로 보조네임노드가 다운돼 있을 수 있는데, 네임노드가 재구동하는 상황이 발생할 경우 editslog 크기가 너무 커서 네임노드의 메모리에 로딩되지 못하는 상황이 발생할 수 있으므로

→ 보조네임노드가 제대로 구동되고 있는지, editslog의 용량이 과도하게 증가하지는 않았는지 확인

## 클러스터 웹 인터페이스

하둡은 HDFS의 기본적인 상태를 모니터링하고 HDFS 내에 저장된 파일을 조회할 수 있게 웹 인터페이스를 제공